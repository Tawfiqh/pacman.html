<!-- Pacman Game TODO list - https://tawfiq.co.uk/pacman
- ‚úÖ Initialise Game State
- ‚úÖ Setup Keyboard Controls
- ‚úÖ Setup Run Loop to update game state and render game
- ‚úÖ Move enemies + player
- ‚úÖ Handle Collisions
- ‚úÖ Add speed to enemies
- ‚úÖ Stop creatures going off of the map!
- ‚úÖ Give enemies colours
- ‚úÖ Update Score
- ‚úÖ Display score
- ‚úÖ Show score on end-screen
- ‚úÖ Resize to window size -- zoom/scale (and centre the play window on the screen)
- ‚úÖ Animate pacman
- ‚úÖ Ghost trails and faces
- ‚úÖ Mobile support for touch
- ‚úÖ Instructions on how to play
- ‚úÖ Fix scrolling on mobile (should not scroll when swiping to play)
- Add cherries!! If the player eats a cherry then they can eat the ghosts! 
- Add walls - that the characters can't move through
- Add more enemies as times goes on!
- Restart button on end-screen
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman üëª1.0</title>
    <style>
        html,
        body {
            /* this is to prevent the page from scrolling when playing on mobile */
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
        }

        .canvas-container {
            position: relative;
            text-align: center;
            padding-top: 44px;
        }

        .instructions-container {
            text-align: center;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 20px 0px;
        }

        .instructions {
            width: 80vw;
        }

        canvas {
            border: 1px solid greenyellow;
            border-radius: 10px;
            width: min(80vw, 80vh);
            height: min(80vw, 80vh);
        }

        #gameOver {
            display: none;
            width: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid greenyellow;
            border-radius: 10px;

            padding: 20px;
            z-index: 10;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;

            background-color: greenyellow;
            color: black;

        }
    </style>
</head>

<body>
    <div class="canvas-container">
        <canvas id="gameBoard"></canvas>
        <div id="gameOver">
            <h1> Score: <span id="finalScore">0</span> </h1>
            <h1> Game Over - refresh to play again </h1>
        </div>
    </div>
    <div class="instructions-container">
        <div class="instructions">
            <h2>Instructions</h2>
            <p>Use the arrow keys or swipe on your mobile to move Pacman! Avoid the ghosts and stay alive for as long as
                possible!</p>
        </div>
    </div>
</body>
<script>
    // .___  ___.      ___       __  .__   __.      _______      ___      .___  ___.  _______ 
    // |   \/   |     /   \     |  | |  \ |  |     /  _____|    /   \     |   \/   | |   ____|
    // |  \  /  |    /  ^  \    |  | |   \|  |    |  |  __     /  ^  \    |  \  /  | |  |__   
    // |  |\/|  |   /  /_\  \   |  | |  . `  |    |  | |_ |   /  /_\  \   |  |\/|  | |   __|  
    // |  |  |  |  /  _____  \  |  | |  |\   |    |  |__| |  /  _____  \  |  |  |  | |  |____ 
    // |__|  |__| /__/     \__\ |__| |__| \__|     \______| /__/     \__\ |__|  |__| |_______|
    class PacmanGame {

        constructor(config) {
            console.log('Welcome to Pacman üëª');

            // 1.
            this.setupGameState(config.mapSize);

            // 2 - Setup the game map - with the map size
            this.renderer = new Renderer(this.gameState.mapSize)

            // 3.
            this.setupKeyboardControls();

            // 4
            this.setupGameRunLoop(config.runLoopInterval);

        }

        setupGameState(mapSize) {
            this.gameState = {
                mapSize: mapSize, // Currently we just support a square map
                enemies: [
                    new Ghost(mapSize / 2, 0, DIRECTIONS.RIGHT, mapSize, "pink"),
                    new Ghost(mapSize / 2, mapSize, DIRECTIONS.LEFT, mapSize, "blue"),
                    new Ghost(mapSize, mapSize / 2, DIRECTIONS.UP, mapSize, "green"),
                    new Ghost(0, mapSize / 2, DIRECTIONS.DOWN, mapSize, "red")
                ],
                player: new Creature(mapSize / 2, mapSize / 2, DIRECTIONS.RIGHT, mapSize),
                score: 0
            };
        }


        movePlayerInDirection(direction) {
            this.gameState.player.direction = direction;
            console.log('MovePlayerInDirection', direction);
        }

        setupKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                console.log('keydown', event.key);
                switch (event.key) {
                    case 'ArrowUp':
                    case 'w':
                        this.movePlayerInDirection(DIRECTIONS.UP);
                        break;
                    case 'ArrowDown':
                    case 's':
                        this.movePlayerInDirection(DIRECTIONS.DOWN);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                        this.movePlayerInDirection(DIRECTIONS.LEFT);
                        break;
                    case 'ArrowRight':
                    case 'd':
                        this.movePlayerInDirection(DIRECTIONS.RIGHT);
                        break;
                }
            });

            document.addEventListener('touchstart', e => {
                this.touchstartX = e.changedTouches[0].screenX
                this.touchstartY = e.changedTouches[0].screenY
            })

            document.addEventListener('touchend', e => {
                this.touchendX = e.changedTouches[0].screenX
                this.touchendY = e.changedTouches[0].screenY
                this.checkSwipeDirection()
            })

        }

        // Mobile Touch logic -Source - https://stackoverflow.com/a/56663695
        // Posted by Damjan Pavlica, modified by community. See post 'Timeline' for change history
        // Retrieved 2025-12-25, License - CC BY-SA 4.0
        touchstartX = 0
        touchendX = 0

        touchstartY = 0
        touchendY = 0

        checkSwipeDirection() {

            let xMovement = this.touchendX - this.touchstartX
            let yMovement = this.touchendY - this.touchstartY
            if (Math.abs(xMovement) > Math.abs(yMovement)) { // More horizontal movement than vertical movement
                if (xMovement > 0) {
                    this.movePlayerInDirection(DIRECTIONS.RIGHT);
                } else {
                    this.movePlayerInDirection(DIRECTIONS.LEFT);
                }
            } else {
                if (yMovement > 0) {
                    this.movePlayerInDirection(DIRECTIONS.DOWN);
                } else {
                    this.movePlayerInDirection(DIRECTIONS.UP);
                }
            }
        }

        runLoop; // this holds the interval id for the run loop so that we can cancel it later when game ends
        setupGameRunLoop(runLoopInterval) {
            this.runLoop = setInterval(() => { //RunLoop Code
                this.updateGameState();
                this.renderGame();
            }, runLoopInterval);
        }

        updateGameState() {
            this.gameState.player.move()// Move player
            this.gameState.score += 1; // Increment score

            // Move enemies
            for (let enemy of this.gameState.enemies) {
                enemy.move()
                let gameHasEnded = enemy.checkCollisionWithPlayer(this.gameState.player)
                if (gameHasEnded) { this.endGame() }
            }

        }

        renderGame() {
            this.renderer.renderGame(this.gameState);
        }

        endGame() {
            clearInterval(this.runLoop) // Cancel the run loop - stop it from updating
            this.renderer.gameOver(this.gameState.score)
        }
    }

    //  __    __   _______  __      .______    _______ .______          _______.
    // |  |  |  | |   ____||  |     |   _  \  |   ____||   _  \        /       |
    // |  |__|  | |  |__   |  |     |  |_)  | |  |__   |  |_)  |      |   (----`
    // |   __   | |   __|  |  |     |   ___/  |   __|  |      /        \   \    
    // |  |  |  | |  |____ |  `----.|  |      |  |____ |  |\  \----.----)   |   
    // |__|  |__| |_______||_______|| _|      |_______|| _| `._____|_______/    
    // Immutable Directions Enum
    const DIRECTIONS = Object.freeze({
        UP: '‚¨ÜÔ∏è',
        DOWN: '‚¨áÔ∏è',
        LEFT: '‚¨ÖÔ∏è',
        RIGHT: '‚û°Ô∏è'
    });

    function randomDirection() {
        const directionsArray = Object.values(DIRECTIONS);
        return directionsArray[Math.floor(Math.random() * directionsArray.length)];
    }


    //      _______..______   .______       __  .___________. _______     _______.
    //     /       ||   _  \  |   _  \     |  | |           ||   ____|   /       |
    //    |   (----`|  |_)  | |  |_)  |    |  | `---|  |----`|  |__     |   (----`
    //     \   \    |   ___/  |      /     |  |     |  |     |   __|     \   \    
    // .----)   |   |  |      |  |\  \----.|  |     |  |     |  |____.----)   |   
    // |_______/    | _|      | _| `._____||__|     |__|     |_______|_______/    
    class Creature {

        constructor(x, y, direction, mapSize, size = globalConstants.creatureSize, speed = globalConstants.initialSpeed) {
            this.x = x;
            this.y = y;
            this.direction = direction;
            this.speed = speed
            this.mapSize = mapSize; // A bit strange to have mapSize here - but needed to check if the creature is off the map -- TBC if can refactor
            this.size = size;
        }

        move() {
            switch (this.direction) {
                case DIRECTIONS.UP:
                    this.y -= this.speed;
                    break;
                case DIRECTIONS.DOWN:
                    this.y += this.speed;
                    break;
                case DIRECTIONS.LEFT:
                    this.x -= this.speed;
                    break;
                case DIRECTIONS.RIGHT:
                    this.x += this.speed;
                    break;
            }
            this.loopAroundIfNeeded();
        }

        loopAroundIfNeeded() {
            if (this.x < 0) { // too far left
                this.x = this.mapSize
            }
            if (this.y < 0) { // too far up
                this.y = this.mapSize
            }
            if (this.x > this.mapSize) { // too far right
                this.x = 0
            }
            if (this.y > this.mapSize) { // too far down
                this.y = 0
            }
        }
    }


    class Ghost extends Creature {
        currentMovesBeforeResetting = 0;
        MAX_MOVES = globalConstants.enemyMaxMovesInSameDirection;

        constructor(x, y, direction, mapSize, color, size = globalConstants.creatureSize, speed = globalConstants.enemySpeed) {
            super(x, y, direction, mapSize, size, speed)
            this.color = color;
        }

        move() {
            super.move();
            this.currentMovesBeforeResetting++;

            if (this.currentMovesBeforeResetting >= this.MAX_MOVES) {
                this.turnAroundRandomlyAndGetFaster();
                this.currentMovesBeforeResetting = 0;
            }
        }

        turnAroundRandomlyAndGetFaster() {
            this.direction = randomDirection();
            this.speed += globalConstants.enemyIncreaseSpeed
        }

        checkCollisionWithPlayer(player) {
            let dx = Math.abs(player.x - this.x);
            let dy = Math.abs(player.y - this.y);
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.size + this.size) {
                return true
            }

            return false
        }

    }

    // .______       _______ .__   __.  _______   _______ .______       _______ .______      
    // |   _  \     |   ____||  \ |  | |       \ |   ____||   _  \     |   ____||   _  \     
    // |  |_)  |    |  |__   |   \|  | |  .--.  ||  |__   |  |_)  |    |  |__   |  |_)  |    
    // |      /     |   __|  |  . `  | |  |  |  ||   __|  |      /     |   __|  |      /     
    // |  |\  \----.|  |____ |  |\   | |  '--'  ||  |____ |  |\  \----.|  |____ |  |\  \----.
    // | _| `._____||_______||__| \__| |_______/ |_______|| _| `._____||_______|| _| `._____|
    class Renderer {

        scaleFactor = globalConstants.scaleFactor; // this is the number of pixels per game unit

        constructor(initialSize) {
            this.canvas = document.getElementById("gameBoard");
            this.ctx = this.canvas.getContext("2d");

            // set width and height to gameState width and height
            this.canvas.width = initialSize * this.scaleFactor;
            this.canvas.height = initialSize * this.scaleFactor;

            this.currentPlayerAnimationFrame = 0;
            this.totalPlayerAnimationFrames = 24;
        }

        renderCharacter(character, color) {
            this.drawCircle(
                character.x,
                character.y,
                character.size,
                color
            )

        }

        renderCharacterFace(character, color) {
            this.renderCharacterMouth(character, color)
            this.renderCharacterEye(character, color)
        }

        renderCharacterMouth(character, color) {

            // How far through the animation are we? Calculate how much of an angle to render
            function calculateMouthArc(percentage) {
                return 0.33 * Math.PI * percentage;
            }


            function calculateDirectionOffset(direction) {
                switch (direction) {
                    case DIRECTIONS.RIGHT: //0 degrees
                        return 0;
                    case DIRECTIONS.LEFT: // 180 degrees to the left
                        return Math.PI;
                    case DIRECTIONS.UP: // TBC - not 100% sure why this is flipped - and not just 0.5 * Math.PI - should be rotated 90 Degrees Anti-Clockwise
                        return 1.5 * Math.PI;
                    case DIRECTIONS.DOWN: // TBC - not 100% sure why this is flipped - and not just 1.5 * Math.PI - should be rotated 270 Degrees Anti-Clockwise
                        return 0.5 * Math.PI;
                }
            }

            const mouthArcAngle = calculateMouthArc(
                this.currentPlayerAnimationFrame / this.totalPlayerAnimationFrames,
            );
            this.currentPlayerAnimationFrame = (this.currentPlayerAnimationFrame + 1) % this.totalPlayerAnimationFrames;

            const directionOffset = calculateDirectionOffset(character.direction);

            // Draw an arc on the face - this is the mouth - which will open and close as the animation progresses
            const ctx = this.ctx
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.arc(
                character.x * this.scaleFactor,
                character.y * this.scaleFactor,
                character.size * this.scaleFactor,
                directionOffset - mouthArcAngle,
                directionOffset + mouthArcAngle,
                false // draw the arc clockwise
            );
            ctx.lineTo(character.x * this.scaleFactor, character.y * this.scaleFactor);
            ctx.stroke();
            ctx.fill();
        }

        renderCharacterEye(character, color) {

            // Draw an eye on the face - this is the left eye - which will move as the animation progresses
            function calculateEyeOffset(direction) {
                let xOffset = 0;
                let yOffset = 0;

                switch (direction) {
                    case DIRECTIONS.RIGHT:
                        xOffset = -1
                        yOffset = -1
                        break;
                    case DIRECTIONS.LEFT:
                        xOffset = 1
                        yOffset = -1
                        break;
                    case DIRECTIONS.UP:
                        xOffset = 1
                        yOffset = 1
                        break;
                    case DIRECTIONS.DOWN:
                        xOffset = -1
                        yOffset = -1
                        break;
                }

                return {
                    x: xOffset * character.size * 0.4,
                    y: yOffset * character.size * 0.4
                };
            }

            const eyeOffset = calculateEyeOffset(character.direction);

            this.drawCircle(
                character.x + eyeOffset.x,
                character.y + eyeOffset.y,
                character.size * 0.2,
                color
            )
        }

        drawCircle(x, y, radius, color) {
            const ctx = this.ctx
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.arc(
                x * this.scaleFactor,
                y * this.scaleFactor,
                radius * this.scaleFactor,
                0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

        }

        clearCanvas() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        renderPlayer(player) {
            this.renderCharacter(player, "yellow")
            this.renderCharacterFace(player, "darkblue")
        }

        renderEnemy(enemy) {
            this.renderCharacter(enemy, enemy.color)
            this.renderGhostTrail(enemy, enemy.color)
            this.renderGhostFace(enemy, enemy.color)
        }

        renderGhostFace(character, color) {
            let eyeOffset = character.size * 0.4
            let eyeRadius = character.size * 0.2

            // Draw the right eye
            this.drawCircle(
                (character.x + eyeOffset),
                (character.y - eyeOffset),
                eyeRadius,
                "darkblue"
            )

            // Draw the left eye
            this.drawCircle(
                (character.x - eyeOffset),
                (character.y - eyeOffset),
                eyeRadius,
                "darkblue"
            )

            // Another circle for the mouth
            this.drawCircle(
                (character.x),
                (character.y + eyeOffset),
                eyeRadius * 1.4,
                "darkblue"
            )
        }

        renderGhostTrail(character, color) {
            const ctx = this.ctx
            ctx.beginPath();

            // 1. Start at the top of the Ghost Head
            const startPosition = [
                character.x * this.scaleFactor,
                (character.y - character.size) * this.scaleFactor
            ]
            ctx.moveTo(startPosition[0], startPosition[1]);

            //2. Move down to the bottom left (with a small offset so that it's larger than just the circle of the character)
            let trailOffset = (character.size * 1.1)

            let bottomLeft = [
                (character.x - trailOffset) * this.scaleFactor,
                (character.y + trailOffset) * this.scaleFactor
            ]
            // Move down to the bottom left
            ctx.lineTo(bottomLeft[0], bottomLeft[1]);


            // 3. Draw a squiggle across to the bottom right (complex-ish bit)
            //  -=-=-=-=- Now draw a squiggle across to the bottom right -=-=-=-=-
            let bottomRight = [
                (character.x + trailOffset) * this.scaleFactor,
                bottomLeft[1] //no Y-variance as it's a flat line horizontally
            ]

            let bottomRightOffsetX = bottomRight[0] - bottomLeft[0]

            let previousPoint = [ // Used within the for loop to calculate the control points
                bottomLeft[0],
                bottomLeft[1]
            ]

            const incrementsInSquiggle = 10
            // For each increment draw an arc 1/10 along the way to the bottom right
            for (let i = 1; i <= incrementsInSquiggle; i++) {
                let nextPointX = bottomLeft[0] + (bottomRightOffsetX * (i / incrementsInSquiggle))
                let nextPointY = bottomLeft[1] //no Y-variance as it's a flat line horizontally

                let controlPointX = previousPoint[0] + (nextPointX - previousPoint[0]) / 2

                let controlPointOffset = i % 2 === 0 ? 10 : -10;
                let controlPointY = bottomLeft[1] + controlPointOffset //Adjust the control point Y-offset to create the squiggle effect

                // Draw an arc to the next point
                ctx.arcTo( // Uses ArcTo: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo
                    controlPointX, controlPointY, // Control point 1
                    nextPointX, nextPointY, // Control point 2
                    bottomRightOffsetX / incrementsInSquiggle
                ) // Radius

                previousPoint = [
                    nextPointX,
                    nextPointY
                ]
            }
            // -=-=-=-=- end of squiggle now move back to the starting point-=-=-=-=-
            // 4. Move back to the starting point
            ctx.moveTo(startPosition[0], startPosition[1]);

            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.fill();

        }

        renderGame(gameState) {
            this.clearCanvas();

            // Render Player
            this.renderPlayer(gameState.player)


            // Render enemies
            for (let enemy of gameState.enemies) {
                this.renderEnemy(enemy)
            }

            // Render score
            this.renderScore(gameState.score);
        }

        renderScore(score) {
            this.ctx.font = "24px 'Courier New', Courier, monospace";
            this.ctx.fillStyle = "greenyellow";
            this.ctx.fillText("Score: " + score, 10, 30);
        }

        gameOver(finalScore) {
            console.log("----GAME OVER = refresh to play again ----")
            document.getElementById("gameOver").style.display = "block";
            document.getElementById("finalScore").innerHTML = finalScore;

        }
    }

    //  __  .__   __.  __  .___________. __       ___       __       __       _______. _______ 
    // |  | |  \ |  | |  | |           ||  |     /   \     |  |     |  |     /       ||   ____|
    // |  | |   \|  | |  | `---|  |----`|  |    /  ^  \    |  |     |  |    |   (----`|  |__   
    // |  | |  . `  | |  |     |  |     |  |   /  /_\  \   |  |     |  |     \   \    |   __|  
    // |  | |  |\   | |  |     |  |     |  |  /  _____  \  |  `----.|  | .----)   |   |  |____ 
    // |__| |__| \__| |__|     |__|     |__| /__/     \__\ |_______||__| |_______/    |_______|
    const globalConstants = { // Put these in a variable so they can easily be tweaked
        initialSpeed: 1,
        creatureSize: 5,
        enemySpeed: 0.8,
        enemyIncreaseSpeed: 0.02,
        enemyMaxMovesInSameDirection: 15,
        scaleFactor: 20,
    }

    const config = {
        mapSize: 100,
        runLoopInterval: 24
    }

    new PacmanGame(config)

</script>